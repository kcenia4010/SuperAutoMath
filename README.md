# SuperAutoMath
SuperAutoMath - это инструмент, призванный помочь разработчику подбирать аппроксимации для математических функций.

## Зачем?
Вычислять стандартные математические функции долго. Вычислять специальные функции на основе стандартных очень долго.
Для решения определенной задачи может быть смысл в выборе определенной аппроксимации.

Приведение аргумента пока останется на плечах пользователя.

### Небольшой экскурс в разработку математических функций

Разработка практически любой функции, требующей вычислений, сводится к следующим шагам:

1. Пристальное вглядывание - мы вспоминаем, какие есть свойства у искомой функции и, если они есть, придумываем, как ими воспользоваться 
2. Приведение аргумента - возможно, у функции есть свойства, позволяющие сократить диапазон, который нам предстоит аппроксимировать, и в этом шаге обычно состоит самая сложная задача в разработке. Универсального рецепта получения такого алгоритма нет, да и существовать он может не всегда. SuperAutoMath эту задачу не решает
3. Аппроксимация - выбор и реализация численного приближения для искомой функции - задача SuperAutoMath
4. Восстановление результата - проделывание приведения аргумента в обратном порядке для получения общего результата из приведенного (если это необходимо)

На всякий случай повторимся - SuperAutoMath решает только пункт 3.

## Как?
SuperAutoMath будет уметь выбирать оптимальную из следующих видов аппроксимаций:
* полиномиальную с разбиением на отрезки
* дробно-полиномиальную 
* комбинацию известных функций

Сейчас SuperAutoMath умеет выбирать оптимальную аппроксимацию из следующего списка:
* ничего :(

## Как это работает?
Выбор и оценка аппроксимации проходит в несколько этапов:

Пункт 0. Спрашиваем у пользователя, какую функцию мы аппроксимируем, на каком отрезке, с какой точностью (single/double precision)

Пункт 1. Передаем пользовательские вводные в Sollya и наши граничные условия (разбиения, степень полинома, тип аппроксимации); забираем из Sollya математическую запись аппроксимацию; формулируем функцию на C

Пункт 2. Тестируем производительность: замеряем на N точек в области определения, сравниваем с лучшим результатом, быстрее - запоминаем и переходим к следующему шагу, медленнее - все бросаем и переходим к пункту 4

Пункт 3. Тестируем точность (секцию об этом мы напишем отдельно), если она нас не устраивает - увеличиваем количество слагаемых; если устраивает - пробуем уменьшать

Пункт 4. Обучаем на опыте первых трех пунктов модель: если нас не устраивает производительность, штрафуем, иначе идем дальше; если нас устраивает точность, поощряем, иначе штрафуем; в любом случае возвращаемся к пункту 1

## Пояснения
Откуда мы берем лучший результат? В качестве отправной точки используем реализацию на основе стандартных библиотек (например, glibc). В процессе подбора аппроксимации переписываем лучший результат самым быстрым из сгенерированных.

В качестве эталона точности предположительно используем MPFR, но это решение по мере разработки может измениться.

Задача - получить точность не меньше заданной и минимизировать время работы.

## Требования
Зависимости:
* Sollya и ее требования (MPFR, MPFI, FPLLL) - математический бэкенд
* TBD - обучение
* Тестирование не требует дополнительных инструментов, переиспользуем зависимости для Sollya

## Интерфейс
TBD

## Построение 
TBD
